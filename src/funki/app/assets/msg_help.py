
HELPMSG = {
    'Getting started': (
        'FUNKI handles data based on the AnnData format. This data structure is'
        'comprised of a main table of e.g. measurements, where columns '
        'represent observations (e.g. cells, samples...) and rows represent '
        'variables (e.g. transcripts, proteins...). This table is then '
        'accompanied of the "obs" and "var" tables, containing information '
        'regarding the observations and variables respectively (i.e. metadata).'
        'There are a few more data structures included, but these are the '
        'basics, if you are interested, you can read more about it in the '
        'original AnnData publication and/or documentation.\n\n'
        'Most of the file formats supported by AnnData are also supported in '
        'FUNKI. These include H5/H5AD, Excel, Loom, MTX, UMI, CSV, TSV or TXT.'
        'Some of these formats allow the storage of metadata along with the '
        'actual data, if that is not the case, you can upload a separate file '
        'with the sample metadata (CSV, TSV or TXT). In the case of the '
        'metadata tables, it is assumed that rows correspond to observations '
        '(e.g. samples, cells, ...) and columns correspond to the metadata '
        'variables (e.g. age, sex, disease state, ...).\n\n'
        'You can load the data and visualize the data tables by using either '
        'the buttons in the home page or by using the corresponding menus on '
        '"File" menus on top of the application.'
    ),
    'Data summary and pseudo-bulking': (
        'In this tab the user can visualize basic summary of the loaded data '
        'set as well as the different varaibles in the metadata.\n\n'
        'Furthermore the user can also apply pseudo-bulking on their '
        'single-cell data set. This allows to summarize the expression of '
        'individual single-cells into samples by adding up their raw counts.'
        'To do this, the user must select a variable from the metadata over '
        'which to summarize the cell expression (e.g. sample, patient, ...).'
        'Furthermore, the user can also select a grouping variable in case '
        'there exists a sub-group from which to subset the samples (e.g. '
        'cell-type).'
    ),
    'Filtering': (
        'Choosing proper filtering parameters is a highly context-dependent '
        'task. Depending on the experimental set up, these filters can vary a '
        'lot. A proper choice requires some expertise and/or some trial and '
        'error. Therefore, feel free to play with the parameters and observe '
        'the resulting distribution of your data with the help of the plots '
        'below. A good strategy is to start with lax thresholds and move up to '
        'more astringent ones.\n\n'
        '- Max. genes per cell:\n'
        'Maximum number of genes per cell. Cells with higher number of '
        'measured genes will be excluded from the data set. This filter is '
        'meant to filter out doublets (i.e. when two cells are sequenced as if '
        'they were a single cell).\n'
        '- Min. genes per cell:\n'
        'Minimum number of genes per cell. Cells with a lower number of '
        'measured genes will be excluded from the data set. This filter aims '
        'to filter out ambient RNA detection from empty droplets.\n'
        '- Max. % mito. genes per cell:\n'
        'Maximum percentage of mitochondrial genes allowed per cell. Cells '
        'with a higher percentage of mitochondrial genes will be excluded from '
        'the data set. Expression of mitochondrial genes in the cytoplasm is '
        'generally an indicator of poor sample quality and/or apoptotic or '
        'lysing cells. Nevertheless, the proportion of mitochondrial genes '
        'in a given sample can also depend on the cell type, condition and '
        'experimental procedure. Therefore, these factors should also be taken '
        'into account when choosing a cut-off for this filter.'
    ),
    'Normalization': (
        'Normalizes each cell by total counts over all genes such that the '
        'total counts of each cell after scaling is equivalent to the '
        'specified size factor. A size factor of one million corresponds to '
        'CPM normalization (counts per million).\n\n'
        'Although optional, it is usually recommended to also log-transform '
        'the data as it helps reduce skewness and the impact of outliers as '
        'well as bringing the data distribution closer to a normal (Gaussian) '
        'distribution. Specifically, the exact transformation applied to each '
        'value (x) corresponds to: y=log(x+1), where log denotes the natural '
        'logarithm. The addition of one to the original value serves two main '
        'purposes: avoiding division by zero causing the resulting value to be '
        'negative infinite and also, since log(1)=0, non-detected genes remain '
        'valued as zero after the transformation. It is also assumed that the '
        'data is log-transformed upon differential expression analysis.'
    ),
    'Dimensionality reduction': (
        'Embedding, also known as dimensionality reduction algorithms, help us '
        'visualize multi-dimensional data (e.g. cells expressing N number of '
        'genes) into a low-dimensional space (e.g. a 2D scatter plot).\n\n'
        '- Harmony:\n'
        'Harmony is an algorithm that aims to reduce batch effects between '
        'data sets based in one or more covariates wich you can select in the '
        'from the meta data available in the drop-down menu below. Note that '
        'the correction is applied over the embedding components and does not '
        'transform the original data itself.\n\n'
        'For the embedding itself you can choose between Principal Component '
        'Analysis (PCA), t-Stochastic Neighbor Embedding (t-SNE) and Unifold '
        'Manifold Approximation and Projection (UMAP). Note that t-SNE and '
        'UMAP have hyperparameters that can be adjusted and can affect the '
        'final embedding.\n\n'
        '- Perplexity (t-SNE):\n'
        'This hyperparameter of the t-SNE embedding is related to the number '
        'of nearest neighbors. As a general rule of thumb, larger data sets '
        'require higher perplexity values, but in general, values are usually '
        'set between 5 and 50.\n'
        '- Min. dist. (UMAP):\n'
        'Minimum distance between data points, the lower the value, the more '
        'closer together will the data points be drawn. This value is relative '
        'to the spread parameter.\n'
        '- Spread (UMAP):\n'
        'The scale at which the embedded points will be spread out, in '
        'combination with min. dist., determines how clumped or spread out are '
        'the embedded data points.\n'
        '- Alpha (UMAP):\n'
        'Initial learning rate for the embedding optimization.\n'
        '- Gamma (UMAP): \n'
        'Weight applied to negative samples in low-dimensional optimization. '
        'Values above one will result in a positive enforcement of negative '
        'samples.\n\n'
        'Finally, you can also choose the variable from the meta data you want '
        'to color your data points by. If you  already applied the clustering, '
        'that option will also be available in the list (named either "leiden" '
        'or "louvain", depending on your choice).'
    ),
    'Clustering': (
        'Clustering aims to group similar data points. The resolution '
        'parameter controls the number of resulting clusters. This is, higher '
        'values increase the number of resulting clusters (i.e. more '
        'granularity) while lower values reduce the number of resulting '
        'clusters. Here you can choose between two graph-based community '
        'detection algorithms to compute the clusters:\n\n'
        '- Leiden:\n'
        'Modified version of Louvain algorithm aiming to address issues with '
        'disconnected communities. This algorithm optimizes a quality function '
        'based on Constant Potts Model (CPM).\n'
        '- Louvain:\n'
        'Louvain algorithm optimizes a modularity function, a metric derived '
        'from the adjacency matrix.'
    ),
    'Differential expression': (
        'Differential expression analysis allows us to comapre expression '
        'between two different conditions or groups of samples.\n\n'
        'In FUNKI you can perform this analysis with two different methods:\n\n'
        '- "Limma":\n'
        'Is an R package designed to compute differential expression between '
        'microarray data, but its principles can be equally applied to other '
        'types of data like proteomics, phosphoproteomics, etc.\n'
        '- "PyDESeq2:"\n'
        'Is the Python implementation of DESeq2 library. This approach is '
        'designed exclusively for single-cell RNA seq data, and it expects raw '
        'transcript counts as input (i.e. integer numbers).\n\n'
        'First, you need to select over which variable of the metadata the '
        'groups of samples are defined (e.g. "condition"). Once selected, you '
        'can then select which values of this variable define the contrasting '
        'groups. For instance, if the metadata table contains a "condition" '
        'column with values "treatment" and "control", you can select these on '
        'the left and right dropdown menus respectively to compute the '
        'differential expression between these.\n\n'
        'Please note that the order matters when it comes to result '
        'interpretation. Following the previous example, if your contrasting '
        'variable is "treatment" and the reference is "control", when you have '
        'a overexpressed gene, one would say this gene is overexpressed as a '
        'consequence of the treatment when compared to control. If the user '
        'were to choose the opposite order, that gene would be underexpressed '
        'or repressed in the control group when compared to control. TLDR; '
        'switching the contrasting/reference variables flips the sign of the '
        'fold-change.'
    ),
    'Enrichment analysis': (
        'In order to perform an erichment analysis, the user can select a '
        'gene set collection across multiple resources containing different '
        'types of molecular information. For further information each of the '
        'resources, all the links can be found in omnipathdb.org/info. In case '
        'that the data set on hand is from a non-human organism, the user can '
        'convert the identifiers via orthology by selecting one of the other '
        'supported organisms in the drop-down menu below.\n\n'
        'Note that depending on the selected gene set collection and '
        'measurement data available, the user can perform the enrichment as an '
        'activity estimation. For instance, if the data at hand is '
        'transcriptomics and the chosen gene set collection contains TF-target '
        'associations (e.g. CollecTRI, DoRothEA), the resulting scores can be '
        'regarded as a proxy of TF activity.\n\n'
        'Regarding the actual enrichment, you can select which method to use '
        'in order to compute the enrichment scores, the default option is ULM '
        '(Univariate Linear Method). Finally, select which differential '
        'expression contrast results to enrich for (computed previously in the '
        'corresponding tab) and then click the button to compute the '
        'enrichment. The plot generated below will show you the top scoring '
        'enriched gene sets.'
    ),
}