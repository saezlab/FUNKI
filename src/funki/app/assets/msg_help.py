
HELPMSG = {
    'Getting started': (
        'FUNKI handles data based on the AnnData format. This data structure is'
        'comprised of a main table of e.g. measurements, where columns '
        'represent observations (e.g. cells, samples...) and rows represent '
        'variables (e.g. transcripts, proteins...). This table is then '
        'accompanied of the "obs" and "var" tables, containing information '
        'regarding the observations and variables respectively (i.e. metadata).'
        'There are a few more data structures included, but these are the '
        'basics, if you are interested, you can read more about it in the '
        'original AnnData publication and/or documentation.\n\n'
        'Most of the file formats supported by AnnData are also supported in '
        'FUNKI. These include H5/H5AD, Excel, Loom, MTX, UMI, CSV, TSV or TXT.'
        'Some of these formats allow the storage of metadata along with the '
        'actual data, if that is not the case, you can upload a separate file '
        'with the sample metadata (CSV, TSV or TXT). In the case of the '
        'metadata tables, it is assumed that rows correspond to observations '
        '(e.g. samples, cells, ...) and columns correspond to the metadata '
        'variables (e.g. age, sex, disease state, ...).\n\n'
        'You can load the data and visualize the data tables by using either '
        'the buttons in the home page or by using the corresponding menus on '
        '"File" menus on top of the application.'
    ),
    'Data summary and pseudo-bulking': (
        'In this tab the user can visualize basic summary of the loaded data '
        'set as well as the different varaibles in the metadata.\n\n'
        'Furthermore the user can also apply pseudo-bulking on their '
        'single-cell data set. This allows to summarize the expression of '
        'individual single-cells into samples by adding up their raw counts.'
        'To do this, the user must select a variable from the metadata over '
        'which to summarize the cell expression (e.g. sample, patient, ...).'
        'Furthermore, the user can also select a grouping variable in case '
        'there exists a sub-group from which to subset the samples (e.g. '
        'cell-type).'
    ),
    'Filtering': (
        'Choosing proper filtering parameters is a highly context-dependent '
        'task. Depending on the experimental set up, these filters can vary a '
        'lot. A proper choice requires some expertise and/or some trial and '
        'error. Therefore, feel free to play with the parameters and observe '
        'the resulting distribution of your data with the help of the plots '
        'below. A good strategy is to start with lax thresholds and move up to '
        'more astringent ones.\n\n'
        '- Max. genes per cell:\n'
        'Maximum number of genes per cell. Cells with higher number of '
        'measured genes will be excluded from the data set. This filter is '
        'meant to filter out doublets (i.e. when two cells are sequenced as if '
        'they were a single cell).\n'
        '- Min. genes per cell:\n'
        'Minimum number of genes per cell. Cells with a lower number of '
        'measured genes will be excluded from the data set. This filter aims '
        'to filter out ambient RNA detection from empty droplets.\n'
        '- Max. % mito. genes per cell:\n'
        'Maximum percentage of mitochondrial genes allowed per cell. Cells '
        'with a higher percentage of mitochondrial genes will be excluded from '
        'the data set. Expression of mitochondrial genes in the cytoplasm is '
        'generally an indicator of poor sample quality and/or apoptotic or '
        'lysing cells. Nevertheless, the proportion of mitochondrial genes '
        'in a given sample can also depend on the cell type, condition and '
        'experimental procedure. Therefore, these factors should also be taken '
        'into account when choosing a cut-off for this filter.'
    ),
    'Normalization': (
        'Normalizes each cell by total counts over all genes such that the '
        'total counts of each cell after scaling is equivalent to the '
        'specified size factor. A size factor of one million corresponds to '
        'CPM normalization (counts per million).\n\n'
        'Although optional, it is usually recommended to also log-transform '
        'the data as it helps reduce skewness and the impact of outliers as '
        'well as bringing the data distribution closer to a normal (Gaussian) '
        'distribution. Specifically, the exact transformation applied to each '
        'value (x) corresponds to: y=log(x+1), where log denotes the natural '
        'logarithm. The addition of one to the original value serves two main '
        'purposes: avoiding division by zero causing the resulting value to be '
        'negative infinite and also, since log(1)=0, non-detected genes remain '
        'valued as zero after the transformation. It is also assumed that the '
        'data is log-transformed upon differential expression analysis.'
    ),
    'Dimensionality reduction': (
        'Embedding, also known as dimensionality reduction algorithms, help us '
        'visualize multi-dimensional data (e.g. cells expressing N number of '
        'genes) into a low-dimensional space (e.g. a 2D scatter plot).\n\n'
        '- Harmony:\n'
        'Harmony is an algorithm that aims to reduce batch effects between '
        'data sets based in one or more covariates wich you can select in the '
        'from the meta data available in the drop-down menu below. Note that '
        'the correction is applied over the embedding components and does not '
        'transform the original data itself.\n\n'
        'For the embedding itself you can choose between Principal Component '
        'Analysis (PCA), t-Stochastic Neighbor Embedding (tSNE) and Unifold '
        'Manifold Approximation and Projection (UMAP) followed by the variable '
        'from the meta data you want to color your data points by. If you '
        'already applied the clustering, that option will also  be available '
        'in the list (named either "leiden" or "louvain", depending on your '
        'choice).'
    ),
    'Clustering': (
        'Clustering aims to group similar data points. The resolution '
        'parameter controls the number of resulting clusters. This is, higher '
        'values increase the number of resulting clusters (i.e. more '
        'granularity) while lower values reduce the number of resulting '
        'clusters. Here you can choose between two graph-based community '
        'detection algorithms to compute the clusters:\n\n'
        '- Leiden:\n'
        'Modified version of Louvain algorithm aiming to address issues with '
        'disconnected communities. This algorithm optimizes a quality function '
        'based on Constant Potts Model (CPM).\n'
        '- Louvain:\n'
        'Louvain algorithm optimizes a modularity function, a metric derived '
        'from the adjacency matrix.'
    ),
    'Differential expression': (
        'Here we perform the differential expression analysis between two '
        'groups of samples thanks to the package "PyDESeq2". First, you need '
        'to select over which variable of the metadata the groups of samples '
        'are defined (e.g. "condition"). Once selected, you can select which '
        'value(s) define the contrasting groups. For instance, if the metadata '
        'table contains a "condition" column with values "treatment" and '
        '"control", you can select these on the left and right dropdown menus '
        'respectively to compute the differential expression between these.'
    ),
    'Gene sets': (
        'Here you can select across multiple resources containing molecular '
        'information you can use for your enrichment. For further information '
        'on them, you can find all the links in omnipathdb.org/info. In case '
        'your data is from a non-human organism, you can convert the '
        'identifiers via orthology in by selecting the target organism in the '
        'drop-down menu below. Furthermore, you can also filter the gene sets '
        'based on several criteria. For instance, if you want to perform an '
        'enrichment over MSigDB Hallmark pathways, you just need to select '
        '"MSigDB", then in the menu for variable to filter by, choose '
        '"collection" and in the variables to include, select "hallmarks", '
        'and then apply the filter. Note that the drop-down menus are '
        'searchable, so you can start typing the name of the resource/variable '
        'to find it faster.'
    ),
    'Enrichment analysis': (
        'Here you can perform the actual enrichment. First, you can select '
        'which method(s) to use to compute the enrichment (by default, it '
        'calculates using the three top-performing methods ULM, MLM and WSUM) '
        'but you can choose others if you are interested. Finally, select over '
        'which variable from the gene set table you want to enrich for '
        '(depending on the resource, this can be e.g. pathways, transcription '
        'factors, enzymes, ...) an then click the button to compute the '
        'enrichment. The plot generated below will show you the top scoring '
        'enriched gene sets based on the consensus across the selected methods.'
    ),
}